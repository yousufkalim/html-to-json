{"version":3,"file":"index.modern.js","sources":["../src/html/HTMLParser.ts","../src/json/const.ts","../src/json/JSONToHTML.ts"],"sourcesContent":["/**\r\n * Convert HTML to JSON\r\n * @author Yousuf Kalim\r\n */\r\nimport { DOMParser } from 'xmldom';\r\nimport { JSONContent } from '../types';\r\n\r\n/**\r\n * Converts HTML Element or string to JSON\r\n * @param element The HTML string or element to convert to JSON.\r\n * @param json A boolean to indicate if the output should be a JSON string.\r\n * @returns {Promise<JSONContent | string>}\r\n */\r\nasync function HTMLParser(element: Element | string, json = false): Promise<JSONContent | string> {\r\n  return await new Promise((resolve, reject) => {\r\n    try {\r\n      const treeObject: any = {};\r\n      let elementToParse: Element;\r\n\r\n      // If string convert to document Node\r\n      if (typeof element === 'string') {\r\n        const parser = new DOMParser();\r\n        const docNode = parser.parseFromString(element, 'text/xml');\r\n        if (docNode.firstChild) {\r\n          elementToParse = docNode.firstChild as Element;\r\n        }\r\n      } else {\r\n        elementToParse = element;\r\n      }\r\n\r\n      // Recursively loop through DOM elements and assign properties to object\r\n      const treeHTML = (element: Element, object = treeObject): void => {\r\n        object.type = element.nodeName;\r\n        const nodeList = element.childNodes;\r\n        if (nodeList !== null) {\r\n          if (nodeList.length) {\r\n            object.content = [];\r\n            for (let i = 0; i < nodeList.length; i++) {\r\n              if (nodeList[i].nodeType === 3) {\r\n                if (nodeList[i].nodeValue) {\r\n                  object.content.push(nodeList[i].nodeValue);\r\n                }\r\n              } else {\r\n                object.content.push({});\r\n                treeHTML(nodeList[i] as Element, object.content[object.content.length - 1]);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (element.attributes !== null) {\r\n          if (element.attributes.length) {\r\n            object.attributes = {};\r\n            for (let i = 0; i < element.attributes.length; i++) {\r\n              object.attributes[element.attributes[i].nodeName] = element.attributes[i].nodeValue;\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      // @ts-expect-error\r\n      treeHTML(elementToParse);\r\n\r\n      resolve(json ? JSON.stringify(treeObject) : treeObject);\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n\r\nexport default HTMLParser;\r\n","/**\r\n * Exports VOID_ELEMENTS\r\n * @author Levix\r\n */\r\nexport const VOID_ELEMENTS = [\r\n  'area',\r\n  'base',\r\n  'br',\r\n  'col',\r\n  'embed',\r\n  'hr',\r\n  'img',\r\n  'input',\r\n  'link',\r\n  'meta',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr',\r\n];\r\n","/**\r\n * Convert JSON to HTML\r\n * @author Yousuf Kalim\r\n */\r\nimport { DOMParser } from 'xmldom';\r\nimport { JSONContent } from '../types';\r\nimport { VOID_ELEMENTS } from './const';\r\n\r\n/**\r\n * Converts JSON content to HTML string or HTML Document object\r\n * @param content The JSON or JS object to convert to HTML Element/String\r\n * @param string A boolean to indicate if the output should be an HTML Element or String.\r\n * @returns {Promise<string | Document>}\r\n */\r\nasync function JSONToHTML(\r\n  content: JSONContent | string,\r\n  string = true, // default to returning a string representation\r\n): Promise<string | Document> {\r\n  return await new Promise((resolve, reject) => {\r\n    try {\r\n      let jsonContent = content;\r\n\r\n      // If input is a string, parse it as JSON\r\n      if (typeof content === 'string') {\r\n        jsonContent = JSON.parse(content) as JSONContent;\r\n      }\r\n\r\n      // Recursively construct HTML string from JSON content\r\n      const treeJSON = (content: JSONContent): string => {\r\n        let html = `<${content.type}`; // Start with opening tag\r\n\r\n        // If there are attributes, add them to the tag\r\n        if (content.attributes) {\r\n          Object.entries(content.attributes).forEach(([attribute, value]) => {\r\n            html += ` ${attribute}=\"${value as string}\"`;\r\n          });\r\n        }\r\n        html += '>';\r\n\r\n        // If there is content, process it and add it to the tag\r\n        if (content.content) {\r\n          content.content.forEach((node) => {\r\n            if (typeof node === 'string') {\r\n              html += node;\r\n            } else {\r\n              html += treeJSON(node);\r\n            }\r\n          });\r\n        }\r\n\r\n        // If it is not an empty element, append the end tag\r\n        if (!VOID_ELEMENTS.includes(content.type)) {\r\n          // End the tag\r\n          html += `</${content.type}>`;\r\n        }\r\n\r\n        return html;\r\n      };\r\n\r\n      // Convert the JSON content to HTML string\r\n      const html = treeJSON(jsonContent as JSONContent);\r\n\r\n      // If string flag is set, return the HTML string\r\n      if (string) {\r\n        resolve(html);\r\n      } else {\r\n        // Otherwise, parse the HTML string to an Element\r\n        const parser = new DOMParser();\r\n        resolve(parser.parseFromString(html, 'text/xml'));\r\n      }\r\n    } catch (e) {\r\n      // Reject the Promise if there's an error\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n\r\nexport default JSONToHTML;\r\n"],"names":["async","HTMLParser","element","json","Promise","resolve","reject","treeObject","elementToParse","docNode","DOMParser","parseFromString","firstChild","treeHTML","object","type","nodeName","nodeList","childNodes","length","content","i","nodeType","nodeValue","push","attributes","JSON","stringify","e","VOID_ELEMENTS","JSONToHTML","string","jsonContent","parse","treeJSON","html","Object","entries","forEach","attribute","value","node","includes"],"mappings":"mCAaAA,eAAeC,EAAWC,EAA2BC,GAAO,GAC1D,aAAa,IAAIC,QAAQ,CAACC,EAASC,KACjC,IACE,MAAMC,EAAkB,CAAA,EACxB,IAAIC,EAGJ,GAAuB,iBAAZN,EAAsB,CAC/B,MACMO,GADS,IAAIC,GACIC,gBAAgBT,EAAS,YAC5CO,EAAQG,aACVJ,EAAiBC,EAAQG,WAE5B,MACCJ,EAAiBN,EAInB,MAAMW,EAAWA,CAACX,EAAkBY,EAASP,KAC3CO,EAAOC,KAAOb,EAAQc,SACtB,MAAMC,EAAWf,EAAQgB,WACzB,GAAiB,OAAbD,GACEA,EAASE,OAAQ,CACnBL,EAAOM,QAAU,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAASE,OAAQE,IACN,IAAzBJ,EAASI,GAAGC,SACVL,EAASI,GAAGE,WACdT,EAAOM,QAAQI,KAAKP,EAASI,GAAGE,YAGlCT,EAAOM,QAAQI,KAAK,CAAA,GACpBX,EAASI,EAASI,GAAeP,EAAOM,QAAQN,EAAOM,QAAQD,OAAS,IAG7E,CAEH,GAA2B,OAAvBjB,EAAQuB,YACNvB,EAAQuB,WAAWN,OAAQ,CAC7BL,EAAOW,WAAa,CAAE,EACtB,IAAK,IAAIJ,EAAI,EAAGA,EAAInB,EAAQuB,WAAWN,OAAQE,IAC7CP,EAAOW,WAAWvB,EAAQuB,WAAWJ,GAAGL,UAAYd,EAAQuB,WAAWJ,GAAGE,SAE7E,CACF,EAIHV,EAASL,GAETH,EAAQF,EAAOuB,KAAKC,UAAUpB,GAAcA,EAC7C,CAAC,MAAOqB,GACPtB,EAAOsB,EACR,GAEL,CC/Da,MAAAC,EAAgB,CAC3B,OACA,OACA,KACA,MACA,QACA,KACA,MACA,QACA,OACA,OACA,QACA,SACA,QACA,OCJF7B,eAAe8B,EACbV,EACAW,GAAS,GAET,aAAa,IAAI3B,QAAQ,CAACC,EAASC,KACjC,IACE,IAAI0B,EAAcZ,EAGK,iBAAZA,IACTY,EAAcN,KAAKO,MAAMb,IAI3B,MAAMc,EAAYd,IAChB,IAAIe,EAAW,IAAAf,EAAQL,OA2BvB,OAxBIK,EAAQK,YACVW,OAAOC,QAAQjB,EAAQK,YAAYa,QAAQ,EAAEC,EAAWC,MACtDL,GAAY,IAAAI,MAAcC,OAG9BL,GAAQ,IAGJf,EAAQA,SACVA,EAAQA,QAAQkB,QAASG,IAErBN,GADkB,iBAATM,EACDA,EAEAP,EAASO,EAClB,GAKAZ,EAAca,SAAStB,EAAQL,QAElCoB,GAAa,KAAAf,EAAQL,SAGhBoB,GAIHA,EAAOD,EAASF,GAIpB3B,EADE0B,EACMI,GAGO,IAAIzB,GACJC,gBAAgBwB,EAAM,YAExC,CAAC,MAAOP,GAEPtB,EAAOsB,EACR,GAEL"}