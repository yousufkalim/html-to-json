{"version":3,"file":"index.umd.js","sources":["../src/html/HTMLParser.ts","../src/json/const.ts","../src/json/JSONToHTML.ts"],"sourcesContent":["/**\r\n * Convert HTML to JSON\r\n * @author Yousuf Kalim\r\n */\r\nimport { DOMParser } from 'xmldom';\r\nimport { JSONContent } from '../types';\r\n\r\n/**\r\n * Converts HTML Element or string to JSON\r\n * @param element The HTML string or element to convert to JSON.\r\n * @param json A boolean to indicate if the output should be a JSON string.\r\n * @returns {Promise<JSONContent | string>}\r\n */\r\nasync function HTMLParser(element: Element | string, json = false): Promise<JSONContent | string> {\r\n  return await new Promise((resolve, reject) => {\r\n    try {\r\n      const treeObject: any = {};\r\n      let elementToParse: Element;\r\n\r\n      // If string convert to document Node\r\n      if (typeof element === 'string') {\r\n        const parser = new DOMParser();\r\n        const docNode = parser.parseFromString(element, 'text/xml');\r\n        if (docNode.firstChild) {\r\n          elementToParse = docNode.firstChild as Element;\r\n        }\r\n      } else {\r\n        elementToParse = element;\r\n      }\r\n\r\n      // Recursively loop through DOM elements and assign properties to object\r\n      const treeHTML = (element: Element, object = treeObject): void => {\r\n        object.type = element.nodeName;\r\n        const nodeList = element.childNodes;\r\n        if (nodeList !== null) {\r\n          if (nodeList.length) {\r\n            object.content = [];\r\n            for (let i = 0; i < nodeList.length; i++) {\r\n              if (nodeList[i].nodeType === 3) {\r\n                if (nodeList[i].nodeValue) {\r\n                  object.content.push(nodeList[i].nodeValue);\r\n                }\r\n              } else {\r\n                object.content.push({});\r\n                treeHTML(nodeList[i] as Element, object.content[object.content.length - 1]);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (element.attributes !== null) {\r\n          if (element.attributes.length) {\r\n            object.attributes = {};\r\n            for (let i = 0; i < element.attributes.length; i++) {\r\n              object.attributes[element.attributes[i].nodeName] = element.attributes[i].nodeValue;\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      // @ts-expect-error\r\n      treeHTML(elementToParse);\r\n\r\n      resolve(json ? JSON.stringify(treeObject) : treeObject);\r\n    } catch (e) {\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n\r\nexport default HTMLParser;\r\n","/**\r\n * Exports VOID_ELEMENTS\r\n * @author Levix\r\n */\r\nexport const VOID_ELEMENTS = [\r\n  'area',\r\n  'base',\r\n  'br',\r\n  'col',\r\n  'embed',\r\n  'hr',\r\n  'img',\r\n  'input',\r\n  'link',\r\n  'meta',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr',\r\n];\r\n","/**\r\n * Convert JSON to HTML\r\n * @author Yousuf Kalim\r\n */\r\nimport { DOMParser } from 'xmldom';\r\nimport { JSONContent } from '../types';\r\nimport { VOID_ELEMENTS } from './const';\r\n\r\n/**\r\n * Converts JSON content to HTML string or HTML Document object\r\n * @param content The JSON or JS object to convert to HTML Element/String\r\n * @param string A boolean to indicate if the output should be an HTML Element or String.\r\n * @returns {Promise<string | Document>}\r\n */\r\nasync function JSONToHTML(\r\n  content: JSONContent | string,\r\n  string = true, // default to returning a string representation\r\n): Promise<string | Document> {\r\n  return await new Promise((resolve, reject) => {\r\n    try {\r\n      let jsonContent = content;\r\n\r\n      // If input is a string, parse it as JSON\r\n      if (typeof content === 'string') {\r\n        jsonContent = JSON.parse(content) as JSONContent;\r\n      }\r\n\r\n      // Recursively construct HTML string from JSON content\r\n      const treeJSON = (content: JSONContent): string => {\r\n        let html = `<${content.type}`; // Start with opening tag\r\n\r\n        // If there are attributes, add them to the tag\r\n        if (content.attributes) {\r\n          Object.entries(content.attributes).forEach(([attribute, value]) => {\r\n            html += ` ${attribute}=\"${value as string}\"`;\r\n          });\r\n        }\r\n        html += '>';\r\n\r\n        // If there is content, process it and add it to the tag\r\n        if (content.content) {\r\n          content.content.forEach((node) => {\r\n            if (typeof node === 'string') {\r\n              html += node;\r\n            } else {\r\n              html += treeJSON(node);\r\n            }\r\n          });\r\n        }\r\n\r\n        // If it is not an empty element, append the end tag\r\n        if (!VOID_ELEMENTS.includes(content.type)) {\r\n          // End the tag\r\n          html += `</${content.type}>`;\r\n        }\r\n\r\n        return html;\r\n      };\r\n\r\n      // Convert the JSON content to HTML string\r\n      const html = treeJSON(jsonContent as JSONContent);\r\n\r\n      // If string flag is set, return the HTML string\r\n      if (string) {\r\n        resolve(html);\r\n      } else {\r\n        // Otherwise, parse the HTML string to an Element\r\n        const parser = new DOMParser();\r\n        resolve(parser.parseFromString(html, 'text/xml'));\r\n      }\r\n    } catch (e) {\r\n      // Reject the Promise if there's an error\r\n      reject(e);\r\n    }\r\n  });\r\n}\r\n\r\nexport default JSONToHTML;\r\n"],"names":["VOID_ELEMENTS","element","json","Promise","resolve","reject","elementToParse","treeObject","docNode","DOMParser","parseFromString","firstChild","treeHTML","object","type","nodeName","nodeList","childNodes","length","content","i","nodeType","nodeValue","push","attributes","JSON","stringify","e","string","jsonContent","parse","html","treeJSON","Object","entries","forEach","_ref","node","includes"],"mappings":"gRAae,ICTFA,EAAgB,CAC3B,OACA,OACA,KACA,MACA,QACA,KACA,MACA,QACA,OACA,OACA,QACA,SACA,QACA,oBDLa,SAAWC,EAA2BC,QAAI,IAAJA,IAAAA,GAAO,GAAK,IAAA,OAAAC,QAAAC,QAClD,IAAID,QAAQ,SAACC,EAASC,GACjC,IACE,IACIC,EADEC,EAAkB,CAAA,EAIxB,GAAuB,iBAAZN,EAAsB,CAC/B,IACMO,GADS,IAAIC,EAAAA,WACIC,gBAAgBT,EAAS,YAC5CO,EAAQG,aACVL,EAAiBE,EAAQG,WAE5B,MACCL,EAAiBL,GAIF,SAAXW,EAAYX,EAAkBY,QAAAA,IAAAA,IAAAA,EAASN,GAC3CM,EAAOC,KAAOb,EAAQc,SACtB,IAAMC,EAAWf,EAAQgB,WACzB,GAAiB,OAAbD,GACEA,EAASE,OAAQ,CACnBL,EAAOM,QAAU,GACjB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAASE,OAAQE,IACN,IAAzBJ,EAASI,GAAGC,SACVL,EAASI,GAAGE,WACdT,EAAOM,QAAQI,KAAKP,EAASI,GAAGE,YAGlCT,EAAOM,QAAQI,KAAK,IACpBX,EAASI,EAASI,GAAeP,EAAOM,QAAQN,EAAOM,QAAQD,OAAS,IAG7E,CAEH,GAA2B,OAAvBjB,EAAQuB,YACNvB,EAAQuB,WAAWN,OAAQ,CAC7BL,EAAOW,WAAa,CAAE,EACtB,IAAK,IAAIJ,EAAI,EAAGA,EAAInB,EAAQuB,WAAWN,OAAQE,IAC7CP,EAAOW,WAAWvB,EAAQuB,WAAWJ,GAAGL,UAAYd,EAAQuB,WAAWJ,GAAGE,SAE7E,CAEL,CAGAV,CAASN,GAETF,EAAQF,EAAOuB,KAAKC,UAAUnB,GAAcA,EAC7C,CAAC,MAAOoB,GACPtB,EAAOsB,EACR,CACH,GACF,CAAC,MAAAA,GAAAxB,OAAAA,QAAAE,OAAAsB,EAED,CAAA,eEvDe,SACbR,EACAS,QAAM,IAANA,IAAAA,GAAS,GAAI,IAAAzB,OAAAA,QAAAC,QAEA,IAAID,QAAQ,SAACC,EAASC,GACjC,IACE,IAAIwB,EAAcV,EAGK,iBAAZA,IACTU,EAAcJ,KAAKK,MAAMX,IAI3B,IAgCMY,EAhCW,SAAXC,EAAYb,GAChB,IAAIY,EAAI,IAAOZ,EAAQL,KA2BvB,OAxBIK,EAAQK,YACVS,OAAOC,QAAQf,EAAQK,YAAYW,QAAQ,SAAAC,GACzCL,GAAI,IADgDK,EAAA,GAC/B,KADsCA,EAAA,GAClB,GAC3C,GAEFL,GAAQ,IAGJZ,EAAQA,SACVA,EAAQA,QAAQgB,QAAQ,SAACE,GAErBN,GADkB,iBAATM,EACDA,EAEAL,EAASK,EAErB,GAIGrC,EAAcsC,SAASnB,EAAQL,QAElCiB,GAAI,KAASZ,EAAQL,KAAI,KAGpBiB,CACT,CAGaC,CAASH,GAIpBzB,EADEwB,EACMG,GAGO,IAAItB,EAAAA,WACJC,gBAAgBqB,EAAM,YAExC,CAAC,MAAOJ,GAEPtB,EAAOsB,EACR,CACH,GACF,CAAC,MAAAA,GAAAxB,OAAAA,QAAAE,OAAAsB,EAED,CAAA"}