{"version":3,"file":"index.umd.js","sources":["../src/json/JSONToHTML.ts","../src/html/HTMLParser.ts"],"sourcesContent":["/**\n * Convert JSON to HTML\n * @author Yousuf Kalim\n */\nimport { DOMParser } from 'xmldom';\nimport { JSONContent } from '../types';\n\n/**\n * Converts JSON content to HTML string or HTML Document object\n * @param content The JSON or JS object to convert to HTML Element/String\n * @param string A boolean to indicate if the output should be an HTML Element or String.\n * @returns {Promise<string | Document>}\n */\nasync function JSONToHTML(\n  content: JSONContent | string,\n  string = true, // default to returning a string representation\n): Promise<string | Document> {\n  return await new Promise((resolve, reject) => {\n    try {\n      let jsonContent = content;\n\n      // If input is a string, parse it as JSON\n      if (typeof content === 'string') {\n        jsonContent = JSON.parse(content) as JSONContent;\n      }\n\n      // Recursively construct HTML string from JSON content\n      const treeJSON = (content: JSONContent): string => {\n        let html = `<${content.type}`; // Start with opening tag\n\n        // If there are attributes, add them to the tag\n        if (content.attributes) {\n          Object.entries(content.attributes).forEach(([attribute, value]) => {\n            html += ` ${attribute}=\"${value as string}\"`;\n          });\n        }\n        html += '>';\n\n        // If there is content, process it and add it to the tag\n        if (content.content) {\n          content.content.forEach((node) => {\n            if (typeof node === 'string') {\n              html += node;\n            } else {\n              html += treeJSON(node);\n            }\n          });\n        }\n\n        // End the tag\n        html += `</${content.type}>`;\n\n        return html;\n      };\n\n      // Convert the JSON content to HTML string\n      const html = treeJSON(jsonContent as JSONContent);\n\n      // If string flag is set, return the HTML string\n      if (string) {\n        resolve(html);\n      } else {\n        // Otherwise, parse the HTML string to an Element\n        const parser = new DOMParser();\n        resolve(parser.parseFromString(html, 'text/xml'));\n      }\n    } catch (e) {\n      // Reject the Promise if there's an error\n      reject(e);\n    }\n  });\n}\n\nexport default JSONToHTML;\n","/**\n * Convert HTML to JSON\n * @author Yousuf Kalim\n */\nimport { DOMParser } from 'xmldom';\nimport { JSONContent } from '../types';\n\n/**\n * Converts HTML Element or string to JSON\n * @param element The HTML string or element to convert to JSON.\n * @param json A boolean to indicate if the output should be a JSON string.\n * @returns {Promise<JSONContent | string>}\n */\nasync function HTMLParser(element: Element | string, json = false): Promise<JSONContent | string> {\n  return await new Promise((resolve, reject) => {\n    try {\n      const treeObject: any = {};\n      let elementToParse: Element;\n\n      // If string convert to document Node\n      if (typeof element === 'string') {\n        const parser = new DOMParser();\n        const docNode = parser.parseFromString(element, 'text/xml');\n        if (docNode.firstChild) {\n          elementToParse = docNode.firstChild as Element;\n        }\n      } else {\n        elementToParse = element;\n      }\n\n      // Recursively loop through DOM elements and assign properties to object\n      const treeHTML = (element: Element, object = treeObject): void => {\n        object.type = element.nodeName;\n        const nodeList = element.childNodes;\n        if (nodeList !== null) {\n          if (nodeList.length) {\n            object.content = [];\n            for (let i = 0; i < nodeList.length; i++) {\n              if (nodeList[i].nodeType === 3) {\n                if (nodeList[i].nodeValue) {\n                  object.content.push(nodeList[i].nodeValue);\n                }\n              } else {\n                object.content.push({});\n                treeHTML(nodeList[i] as Element, object.content[object.content.length - 1]);\n              }\n            }\n          }\n        }\n        if (element.attributes !== null) {\n          if (element.attributes.length) {\n            object.attributes = {};\n            for (let i = 0; i < element.attributes.length; i++) {\n              object.attributes[element.attributes[i].nodeName] = element.attributes[i].nodeValue;\n            }\n          }\n        }\n      };\n\n      // @ts-expect-error\n      treeHTML(elementToParse);\n\n      resolve(json ? JSON.stringify(treeObject) : treeObject);\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nexport default HTMLParser;\n"],"names":["content","string","Promise","resolve","reject","jsonContent","JSON","parse","html","type","attributes","Object","entries","forEach","_ref","attribute","value","node","treeJSON","DOMParser","parseFromString","e","HTMLParser","element","json","elementToParse","treeObject","docNode","firstChild","treeHTML","object","nodeName","nodeList","childNodes","length","i","nodeType","nodeValue","push","_i","stringify"],"mappings":"6RAayB,SACvBA,EACAC,YAAAA,IAAAA,GAAS,GAAI,IAAA,OAAAC,QAAAC,QAEA,IAAID,QAAQ,SAACC,EAASC,GACjC,IACE,IAAIC,EAAcL,EAGK,iBAALA,IAChBK,EAAcC,KAAKC,MAAMP,IAI3B,IA6BMQ,EA7BW,WAACR,GAChB,IAAIQ,MAAWR,EAAQS,KAwBvB,OArBIT,EAAQU,YACVC,OAAOC,QAAQZ,EAAQU,YAAYG,QAAQ,SAAuBC,GAChEN,GAAYO,IADwCD,EAAA,GAC1BE,KAA1BR,EAAAA,MACF,GAEFA,GAAQ,IAGJR,EAAQA,SACVA,EAAQA,QAAQa,QAAQ,SAACI,GAErBT,GADkB,mBACVS,EAEAC,EAASD,EAErB,GAIFT,GAAI,KAASR,EAAQS,KAAI,GAG3B,CAGaS,CAASb,GAIpBF,EADEF,EACMO,GAGO,IAAIW,EAAAA,WACJC,gBAAgBZ,EAAM,YAKxC,CAHC,MAAOa,GAEPjB,EAAOiB,EACR,CACH,GAGF,CAFC,MAEDA,GAAA,OAAAnB,QAAAE,OAAAiB,EAAA,CAAA,YC5DeC,SAAWC,EAA2BC,QAAI,IAAJA,IAAAA,GAAO,GAAK,IAAA,OAAAtB,QAAAC,QAClD,IAAWD,QAAC,SAACC,EAASC,GACjC,IACE,IAC2BqB,EADrBC,EAAkB,CAAA,EAIxB,GAAuB,iBAAZH,EAAsB,CAC/B,IACMI,GADS,IAAeR,EAAAA,WACPC,gBAAgBG,EAAS,YAC5CI,EAAQC,aACVH,EAAiBE,EAAQC,WAE5B,MACCH,EAAiBF,GAIF,SAAXM,EAAYN,EAAkBO,YAAAA,IAAAA,EAASJ,GAC3CI,EAAOrB,KAAOc,EAAQQ,SACtB,IAAMC,EAAWT,EAAQU,WACzB,GAAiB,OAAbD,GACEA,EAASE,OAAQ,CACnBJ,EAAO9B,QAAU,GACjB,IAAK,IAAImC,EAAI,EAAGA,EAAIH,EAASE,OAAQC,IACN,IAAzBH,EAASG,GAAGC,SACVJ,EAASG,GAAGE,WACdP,EAAO9B,QAAQsC,KAAKN,EAASG,GAAGE,YAGlCP,EAAO9B,QAAQsC,KAAK,IACpBT,EAASG,EAASG,GAAeL,EAAO9B,QAAQ8B,EAAO9B,QAAQkC,OAAS,IAG7E,CAEH,GAA2B,OAAvBX,EAAQb,YACNa,EAAQb,WAAWwB,OAAQ,CAC7BJ,EAAOpB,WAAa,CAAE,EACtB,IAAK,IAAK6B,EAAG,EAAGJ,EAAIZ,EAAQb,WAAWwB,OAAQC,IAC7CL,EAAOpB,WAAWa,EAAQb,WAAWyB,GAAGJ,UAAYR,EAAQb,WAAWyB,GAAGE,SAE7E,CAEL,CAGAR,CAASJ,GAETtB,EAAQqB,EAAOlB,KAAKkC,UAAUd,GAAcA,EAG7C,CAFC,MAAOL,GACPjB,EAAOiB,EACR,CACH,GACD,CAAA,MAAAA,GAAA,OAAAnB,QAAAE,OAAAiB,EAAA,CAAA"}